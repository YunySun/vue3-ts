<!--
 * @Description: 
 * @Author: 李昶
 * @Date: 2022-10-31 16:06:31
 * @LastEditors: 李昶
 * @LastEditTime: 2022-10-31 22:38:31
 * @Profile: 一个比较废柴的前端开发
-->
<template>
    <div class="basic-05-wrapper article-wrapper">
        <h2 class="article-title project__title">内存管理：从创建到消亡</h2>
        <p>
            通过单一的所有权模式，Rust解决了内存过于灵活、不容易安全高效地释放的问题，既避免了手工释放内存带来的潜在的错误，也避免了全局引入追踪式GC或者ARC这样的额外机制带来的效率问题。
        </p>
        <h3 class="project__title">内存管理</h3>
        <p>
            栈内存“分配”和“释放”都很高效，在编译期就确定好了，因而它无法安全承载动态大小或者生命周期超出帧存活范围外的值。所以，需要运行时可以自由操控的内存，也就是堆内存，来弥补栈的缺点。
        </p>
        <p>
            大部分堆内存的需求在于动态大小，小部分需求是更长的生命周期。所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子leaked机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。
        </p>
        <h3 class="project__title">值的创建</h3>
        <p>
            当为数据结构创建一个值，并赋给一个变量的时候，根据值得性质，可能会被创建在栈上，也可能被创建在堆上。编译时
            可以确定大小的值都会放在栈上，如原生类型的字符、数组、元组等，以及自定义固定大小的结构体struct、枚举enum等。如果数据结构大小无法确定，或者大小确定但是需要更长的生命周期，就最好放在堆上。
        </p>
        <h3 class="project__title">struct</h3>
        <p>Rust在内存中排布数据时，会根据每个域对齐对数据进行重排，使其内存大小和访问效率最好。</p>
        <p>
            两个数据结构S1和S2都有三个域a、b、c，其中a和c是u8，占用一个字节，b是u16，占用两个字节。而S1和S2的大小却不一样，S1是6个字节，S2是4个字节。这是因为CPU在加载不对齐内存的时候，性能会急剧下降，所以要避免用户定义不对其的数据结构，造成性能影响。
        </p>
        <p>C语言对结构体的处理</p>
        <ul>
            <li>首先确定每个域的长度和对齐长度，原始类型的对齐长度和类型的长度一致。</li>
            <li>每个域的起始位置要和其对齐长度对齐，如果无法对齐，则添加 padding 直至对齐。</li>
            <li>结构体的对齐大小和其最大域的对齐大小相同，而结构体的长度则四舍五入到其对齐的倍数。</li>
        </ul>
        <p></p>
        <p>
            对于S1，字段a是u8类型，所以其长度和对齐都是1，b是u16，其长度和对齐是2。然而因为a只占了一个字节，b的偏移是1，根据第二条规则，起始位置和b的长度无法对齐，所以编译器会添加一个字节的padding，让b的偏移为2，这样b就对齐了。随后c长度和对齐都是1，不需要padding。这样算下来，S1的大小是5，但根据上面的第三条规则，S1的对齐是2，和5最接近的“2的倍数”是6，所以S1最终的长度是6。所以，如果结构体的定义考虑地不够周全，会为了对齐浪费很多空间。
        </p>
        <p>rust编译器自动完成了这个优化，重排定义的结构体，达到最高效率。</p>
        <highlightjs lang="rust" :code="demo1" />
        <p>
            Rust编译器默认为开发者优化结构体的排列，但你也可以使用#[repr]宏，强制让Rust编译器不做优化，和C的行为一致，这样，Rust代码可以方便地和C代码无缝交互。
        </p>
        <h3 class="project__title">enum</h3>
        <p>标签联合体，大小是标签的大小加上最大类型的长度。</p>
        <p>Option是有值/无值最简单的枚举类型，Result包括成功返回数据和错误返回数据的枚举类型。</p>
        <p>
            根据以上3个规则，tag后的内存，会根据其对齐大小进行对齐，所以对于Option&lt;u8&gt;，其长度为1+1=2字节，而Option&lt;f64&gt;，长度是8+8=16字节。一般而言，64位CPU下，enum最大长度是：最大类型的长度+8，因为64位CPU的最大对其是64bit，也就是8个字节。
        </p>
        <highlightjs lang="rust" :code="demo2" />
        <p>
            这段代码声明宏show_size。运行这段代码后发现，Option配合带有引用类型的数据结构，比如&u8、Box、Vec、HashMap，没有占用额外的空间。
        </p>
        <highlightjs lang="rust" :code="demo3" />
        <p>
            对于option结构来说，tag只有2种情况：0或1，tag为0时，表示None，tag为1时，表示Some。正常来说，将它和一个引用放在一起的时候，虽然tag只占1个bit，但是64位CPU下，引用结构的对齐是8，所以它自己加上额外的padding，会占据8个字节，一共16个字节，这是非常耗费内存的。
        </p>
        <p>
            Rust引用类型的第一个域是个指针，而指针是不可能等于0的。但可以复用这个指针，当其为0时，表示None,
            否则就是Some，减少内存的占用。
        </p>
        <h3 class="project__title">vec&lt;T&gt;和String</h3>
        <p>
            Vec&lt;T&gt;和String占用的大小是相同的，都是24个字节。其实String的结构源码内部就是Vec&lt;T&gt;。Vec&lt;T&gt;是3个word的胖指针，包含一个指向堆内存的指针pointer、分配内存的容量capacity，以及数据在堆内存长度length。
        </p>
        <p>很多动态大小的数据结构，在创建时都有类似的内存布局：栈内存放的胖指针，指向堆内存分配出来的数据。</p>
        <h3 class="project__title">值的使用</h3>
        <p>
            一个值如果没有实现Copy，在赋值、传参以及函数返回时会被Move。Copy和Move在内部实现上，都是浅层的按位做内存复制，只不过Copy允许你访问之前的变量，而Move不允许。
        </p>
        <p>
            内存复制是个很重的操作，效率也很低。如果每次调用都要复制一大堆的数据，是很低效的。但是如果复制的是原生类型或者栈上的胖指针，不涉及堆内存的复制也就是深拷贝，这个效率是非常高的，并且不必担心每次复制或者每次传参带来的性能损失。所以，无论是Copy还是Move，它的效率都是非常高的。
        </p>
        <p>
            例外：对栈上的大数组传参，由于需要复制整个数组，会影响效率。所以，一般建议在栈上不要放大数组，如果实在需要，那么传递这个数组时，最好用传引用而不是传值。在使用值的过程中，除了Move，还需要注意值的动态增长。因为Rust下，集合类型的数据结构，都会在使用过程中自动扩展。
        </p>
        <p>
            以一个Vec为例，当你使用完堆内存目前的容量后，还继续添加新的内容，就会触发堆内存的自动增长。有时候，集合类型里的数据不断进进出出，导致集合一直增长，但只使用了很小部分的容量，内存的使用效率很低，所以你要考虑使用，比如shrink_to_fit方法，来节约对内存的使用。
        </p>
        <h3 class="project__title">值的销毁</h3>
        <p>
            这里用到了Drop trait。Drop trait类似面向对象编程中的析构函数，当一个值要被释放，它的Drop trait
            会被调用。比如下面的代码，变量greeting是一个字符串，在退出作用域时，其drop()函数被自动调用，释放堆上包含“hello
            world”的内存，然后再释放栈上的内存。
        </p>
        <img src="../../assets/img/12.png" width="800" />
        <p>
            如果要释放的值是一个复杂的数据结构，比如一个结构体，那么这个结构体在调用drop()时，会依次调用每一个域的drop()
            函数，如果域又是一个复杂的结构或者集合类型，就会递归下去，直到每一个域都释放干净。
        </p>
        <img src="../../assets/img/13.png" width="800" />
        <p>
            代码中的student变量是一个结构体，有name、age、scores。其中name是 String，scores是HashMap，它们本身需要额外
            drop()。又因为HashMap的key是String，所以还需要进一步调用这些key的drop()。整个释放顺序从内到外是：先释放HashMap下的key，然后释放HashMap堆上的表结构，最后释放栈上的内存。
        </p>
        <h3 class="project__title">堆内存释放</h3>
        <p>
            所有权机制规定了，一个值只能有一个所有者，所以在释放堆内存的时候，整个过程简单清晰，就是单纯调用Drop
            trait，不需要有其他顾虑。这种对值安全，也没有额外负担的释放能力，是Rust独有的。Rust在内存管理方面的设计特别像蚁群。在蚁群中，每个个体的行为都遵循着非常简单死板的规范，最终，大量简单的个体能构造出一个高效且不出错的系统。在Rust里，你自定义的数据结构，绝大多数情况下，不需要实现自己的Drop
            trait，编译器缺省的行为就足够了。但是，如果你想自己控制drop行为，你也可以为这些数据结构实现它。如果你定义的
            drop()函数和系统自定义的drop()函数都drop()某个域，Rust编译器会确保，这个域只会被drop一次。
        </p>
        <h3 class="project__title">释放其他资源</h3>
        <p>
            Drop
            trait可以应对堆内存释放的问题，其实，它还可以释放任何资源，比如socket、文件、锁等等。Rust对所有的资源都有很好的RAII支持。比如我们创建一个文件file，往里面写入“hello
            world”，当file离开作用域时，不但它的内存会被释放，它占用的资源、操作系统打开的文件描述符，也会被释放，也就是文件会自动被关闭。
        </p>
        <highlightjs lang="rust" :code="demo4" />
        <p>
            在其他语言，都需要关闭文件，避免资源泄露。这是因为，即便GC能够帮助开发者最终释放不再引用的内存，它并不能释放除内存外的其它资源。而Rust，因为其清晰的所有权界定，使编译器清楚地知道：当一个值离开作用域的时候，这个值不会有任何人引用，它占用的任何资源，包括内存资源，都可以立即释放，而不会导致问题。
        </p>
        <img src="../../assets/img/14.png" width="800" />
        <h3>参考资料</h3>
        Rust 语言的备忘清单
        <a class="link" _target="blank" href="https://cheats.rs/">cheats.rs</a>
    </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import data from '@/data/rust/05BasicData';

export default defineComponent({
    name: '05BasicPage',
    setup() {
        return {
            ...data,
        };
    },
});
</script>

<style scoped lang="scss"></style>
