<!--
 * @Description: 
 * @Author: 李昶
 * @Date: 2022-10-31 16:06:31
 * @LastEditors: 李昶
 * @LastEditTime: 2022-10-31 17:26:24
 * @Profile: 一个比较废柴的前端开发
-->
<template>
    <div class="basic-05-wrapper article-wrapper">
        <h2 class="article-title project__title">内存管理：从创建到消亡</h2>
        <p>
            通过单一的所有权模式，Rust解决了内存过于灵活、不容易安全高效地释放的问题，既避免了手工释放内存带来的潜在的错误，也避免了全局引入追踪式GC或者ARC这样的额外机制带来的效率问题。
        </p>
        <h3 class="project__title">内存管理</h3>
        <p>
            栈内存“分配”和“释放”都很高效，在编译期就确定好了，因而它无法安全承载动态大小或者生命周期超出帧存活范围外的值。所以，需要运行时可以自由操控的内存，也就是堆内存，来弥补栈的缺点。
        </p>
        <p>
            大部分堆内存的需求在于动态大小，小部分需求是更长的生命周期。所以它默认将堆内存的生命周期和使用它的栈内存的生命周期绑在一起，并留了个小口子leaked机制，让堆内存在需要的时候，可以有超出帧存活期的生命周期。
        </p>
        <h3 class="project__title">值的创建</h3>
        <p>
            当为数据结构创建一个值，并赋给一个变量的时候，根据值得性质，可能会被创建在栈上，也可能被创建在堆上。编译时
            可以确定大小的值都会放在栈上，如原生类型的字符、数组、元组等，以及自定义固定大小的结构体struct、枚举enum等。如果数据结构大小无法确定，或者大小确定但是需要更长的生命周期，就最好放在堆上。
        </p>
        <h3 class="project__title">struct</h3>
        <p>Rust在内存中排布数据时，会根据每个域对齐对数据进行重排，使其内存大小和访问效率最好。</p>
        <p>
            两个数据结构S1和S2都有三个域a、b、c，其中a和c是u8，占用一个字节，b是u16，占用两个字节。而S1和S2的大小却不一样，S1是6个字节，S2是4个字节。这是因为CPU在加载不对齐内存的时候，性能会急剧下降，所以要避免用户定义不对其的数据结构，造成性能影响。
        </p>
        <p>C语言对结构体的处理</p>
        <ul>
            <li>首先确定每个域的长度和对齐长度，原始类型的对齐长度和类型的长度一致。</li>
            <li>每个域的起始位置要和其对齐长度对齐，如果无法对齐，则添加 padding 直至对齐。</li>
            <li>结构体的对齐大小和其最大域的对齐大小相同，而结构体的长度则四舍五入到其对齐的倍数。</li>
        </ul>
        <p></p>
        <p>
            对于S1，字段a是u8类型，所以其长度和对齐都是1，b是u16，其长度和对齐是2。然而因为a只占了一个字节，b的偏移是1，根据第二条规则，起始位置和b的长度无法对齐，所以编译器会添加一个字节的padding，让b的偏移为2，这样b就对齐了。随后c长度和对齐都是1，不需要padding。这样算下来，S1的大小是5，但根据上面的第三条规则，S1的对齐是2，和5最接近的“2的倍数”是6，所以S1最终的长度是6。所以，如果结构体的定义考虑地不够周全，会为了对齐浪费很多空间。
        </p>
        <p>rust编译器自动完成了这个优化，重排定义的结构体，达到最高效率。</p>
        <highlightjs lang="rust" :code="demo1" />
        <p>
            Rust编译器默认为开发者优化结构体的排列，但你也可以使用#[repr]宏，强制让Rust编译器不做优化，和C的行为一致，这样，Rust代码可以方便地和C代码无缝交互。
        </p>
        <h3 class="project__title">enum</h3>
        <p>标签联合体，大小是标签的大小加上最大类型的长度。</p>
        <p>Option是有值/无值最简单的枚举类型，Result包括成功返回数据和错误返回数据的枚举类型。</p>
    </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import data from '@/data/rust/05BasicData';

export default defineComponent({
    name: '05BasicPage',
    setup() {
        return {
            ...data,
        };
    },
});
</script>

<style scoped lang="scss"></style>
